#include "parsecommand.h"
#include "execstages.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

#define MAXLEN 512
#define MAXSTAGES 10

struct stage **readline(FILE *insource) {
    struct stage **stages = calloc(sizeof(struct stage *), MAXSTAGES+1);
    /*MAXLEN + null terminated*/
    char **tokens = calloc(sizeof(char *), MAXLEN+1);
    if(!tokens) {
        perror("calloc");
        exit(-1);
    }

    char **lineptr = (char **)malloc(sizeof(char *));

    if(!lineptr) {
        perror("calloc");
        exit(-1);
    }

    *lineptr = NULL;

    size_t *n = malloc(sizeof(size_t));
    if(!n) {
        perror("calloc");
        exit(-1);
    }
    *n = 0;

    char *line;
    char *token;
    int i;

    if(-1 == getline(lineptr, n, insource)) {
        perror("getline");
        exit(-1);
    };

    if(*n > MAXLEN) {
        fprintf(stderr,"line too long\n");
        return NULL;
    }

    line = *lineptr;

    token = strtok(line, " \n");
    for(i = 0; token; i++) {
        tokens[i] = calloc(1,MAXLEN);
        if(!tokens[i]) {
            perror("calloc");
            exit(-1);
        }
        strcpy(tokens[i], token);
        token = strtok(NULL, " \n");
    }

    if(!tokens[0]) {
        return NULL;
    }

    int err = parsecommand(tokens, stages, 0, 0, 0);
    if(err) {
        return NULL;
    }

    for(i = 0; i < MAXLEN; i++) {
        if(tokens[i]) {
            free(tokens[i]);
        }
    }

    free(tokens);
    if(*lineptr) {
        free(*lineptr);
    }
    free(lineptr);
    free(n);
    return stages;
}

void freestages(struct stage **stages) {
    /*Free all memory in list of stage structs*/
    int i;
    for(i = 0; stages[i]; i++) {
        int j;
        for(j = 0; j < stages[i]->argc; j++) {
            free(stages[i]->argv[j]);
        }
        free(stages[i]->argv);
        free(stages[i]);
    }
    free(stages);
}

/*a function to block interrupt signals*/
void blocksignals() {
    sigset_t mask;
    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);
    /*create the sigprocmask to block signals*/
    if(sigprocmask(SIG_BLOCK, &mask, NULL) == -1) {
        perror("SIGBLOCK");
        exit(3);
    }
}
/*a function to unblock interrupt signals*/
void unblocksignals() {
    sigset_t mask;
    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);
    /*create the sigprocmask to unblock signals*/
    if(sigprocmask(SIG_UNBLOCK, &mask, NULL) == -1) {
        perror("SIGUNBLOCK");
        exit(3);
    }
}

void int_handler(int signum) {
    /*wait around*/;
}

int main(int argc, char *argv[]) {
    FILE *commands;
    struct stage **stages;
    struct sigaction sa;

    /*initialize signal handling*/
    sa.sa_handler = int_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(SIGINT, &sa, NULL);

    unblocksignals();

    if(argc == 1) {
        commands = stdin;
    } else {
        commands = fopen(argv[1],"r");
    }

    while(!feof(commands)) {
        if(isatty(STDIN_FILENO) && isatty(STDOUT_FILENO)) {
            printf("8-P ");
            fflush(stdout);
        }

        stages = readline(commands);

        if(stages) {
            execstages(stages);
            freestages(stages);
        } else if(ferror(commands)) {
            /*Clear error generated by interrupt*/
            clearerr(commands);
        }

        while(wait(NULL) > 0) {
            /*Wait for all children*/;
        }
    }
    if(stages) {
        freestages(stages);
    }
    exit(0);
}
